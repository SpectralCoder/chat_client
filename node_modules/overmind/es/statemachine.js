import { PROXY_TREE, VALUE } from 'proxy-state-tree';
const INITIAL_STATE = Symbol('INITIAL_STATE');
const TRANSITIONS = Symbol('TRANSITIONS');
class StateMachine {
    constructor(transitions, definition) {
        this[INITIAL_STATE] = definition.state;
        this[TRANSITIONS] = transitions;
        Object.assign(this, definition);
    }
    transition(state) {
        const transitions = this[VALUE][TRANSITIONS];
        if (transitions[this.state].includes(state)) {
            const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE]);
            tree.enableMutations();
            this.state = state;
            Promise.resolve().then(() => tree.blockMutations());
            return this;
        }
        else if (process.env.NODE_ENV === 'development' && state !== this.state) {
            console.warn(`Overmind Statemachine - You tried to transition into "${state}", but it is not a valid transition. The valid transitions are ${JSON.stringify(transitions[this.state])}`);
        }
        else if (process.env.NODE_ENV === 'development' && state === this.state) {
            console.warn(`Overmind Statemachine - You tried to transition into "${state}", but you are already in this state. Do a "match" before running this piece of logic or add it as a valid state transition for this state`);
        }
    }
    matches(state) {
        if (state === this.state) {
            const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE]);
            // Might be used outside of action
            tree.enableMutations && tree.enableMutations();
            return true;
        }
        return false;
    }
}
export function statemachine(definition, state) {
    return new StateMachine(definition, state);
}
//# sourceMappingURL=statemachine.js.map