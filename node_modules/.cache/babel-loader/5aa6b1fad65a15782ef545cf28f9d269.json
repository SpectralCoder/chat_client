{"ast":null,"code":"import { PROXY_TREE, VALUE } from 'proxy-state-tree';\nconst INITIAL_STATE = Symbol('INITIAL_STATE');\nconst TRANSITIONS = Symbol('TRANSITIONS');\n\nclass StateMachine {\n  constructor(transitions, definition) {\n    this[INITIAL_STATE] = definition.state;\n    this[TRANSITIONS] = transitions;\n    Object.assign(this, definition);\n  }\n\n  transition(state) {\n    const transitions = this[VALUE][TRANSITIONS];\n\n    if (transitions[this.state].includes(state)) {\n      const tree = this[PROXY_TREE].master.mutationTree || this[PROXY_TREE];\n      tree.enableMutations();\n      this.state = state;\n      Promise.resolve().then(() => tree.blockMutations());\n      return this;\n    } else if (process.env.NODE_ENV === 'development' && state !== this.state) {\n      console.warn(`Overmind Statemachine - You tried to transition into \"${state}\", but it is not a valid transition. The valid transitions are ${JSON.stringify(transitions[this.state])}`);\n    } else if (process.env.NODE_ENV === 'development' && state === this.state) {\n      console.warn(`Overmind Statemachine - You tried to transition into \"${state}\", but you are already in this state. Do a \"match\" before running this piece of logic or add it as a valid state transition for this state`);\n    }\n  }\n\n  matches(state) {\n    if (state === this.state) {\n      const tree = this[PROXY_TREE].master.mutationTree || this[PROXY_TREE]; // Might be used outside of action\n\n      tree.enableMutations && tree.enableMutations();\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexport function statemachine(definition, state) {\n  return new StateMachine(definition, state);\n}","map":{"version":3,"sources":["../src/statemachine.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,EAAqB,KAArB,QAAkC,kBAAlC;AAyBA,MAAM,aAAa,GAAG,MAAM,CAAC,eAAD,CAA5B;AACA,MAAM,WAAW,GAAG,MAAM,CAAC,aAAD,CAA1B;;AAEA,MAAM,YAAN,CAAkB;AAGhB,EAAA,WAAA,CAAY,WAAZ,EAA0D,UAA1D,EAA4E;AAC1E,SAAK,aAAL,IAAsB,UAAU,CAAC,KAAjC;AACA,SAAK,WAAL,IAAoB,WAApB;AACA,IAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB,UAApB;AACD;;AACD,EAAA,UAAU,CAAC,KAAD,EAAM;AACd,UAAM,WAAW,GAAG,KAAK,KAAL,EAAY,WAAZ,CAApB;;AACA,QAAI,WAAW,CAAC,KAAK,KAAN,CAAX,CAAwB,QAAxB,CAAiC,KAAjC,CAAJ,EAA6C;AAC3C,YAAM,IAAI,GAAI,KAAK,UAAL,EAAiB,MAAjB,CAAwB,YAAxB,IAAwC,KAAK,UAAL,CAAtD;AACA,MAAA,IAAI,CAAC,eAAL;AACA,WAAK,KAAL,GAAa,KAAb;AACA,MAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAAuB,MAAM,IAAI,CAAC,cAAL,EAA7B;AACA,aAAO,IAAP;AACD,KAND,MAMO,IAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,aAAzB,IAA0C,KAAK,KAAK,KAAK,KAA7D,EAAoE;AACzE,MAAA,OAAO,CAAC,IAAR,CAAa,yDAAyD,KAAK,kEAAkE,IAAI,CAAC,SAAL,CAAe,WAAW,CAAC,KAAK,KAAN,CAA1B,CAAuC,EAApL;AACD,KAFM,MAEA,IAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,aAAzB,IAA0C,KAAK,KAAK,KAAK,KAA7D,EAAoE;AACzE,MAAA,OAAO,CAAC,IAAR,CAAa,yDAAyD,KAAK,4IAA3E;AACD;AACF;;AACD,EAAA,OAAO,CAAC,KAAD,EAAM;AACX,QAAI,KAAK,KAAK,KAAK,KAAnB,EAA0B;AACxB,YAAM,IAAI,GAAI,KAAK,UAAL,EAAiB,MAAjB,CAAwB,YAAxB,IAAwC,KAAK,UAAL,CAAtD,CADwB,CAExB;;AACA,MAAA,IAAI,CAAC,eAAL,IAAwB,IAAI,CAAC,eAAL,EAAxB;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;;AA/Be;;AAkClB,OAAM,SAAU,YAAV,CAA+C,UAA/C,EAA4F,KAA5F,EAAyG;AAC7G,SAAO,IAAI,YAAJ,CAAiB,UAAjB,EAA6B,KAA7B,CAAP;AACD","sourcesContent":["import { PROXY_TREE, VALUE } from 'proxy-state-tree'\n\nimport { IState } from '.'\n\ntype TStates = IState & {\n  state: string | number,\n}\n\nexport type StatemachineTransitions<States extends TStates> = {\n  [State in States[\"state\"]]: Array<States[\"state\"]>\n}\n\nexport interface MachineMethods<States extends TStates> {\n  matches<T extends States[\"state\"]>(state: T): this is Statemachine<States, States extends {\n    state: T\n} ? States : never>;\n  transition<T extends States[\"state\"]>(\n    state: T,\n  ): undefined | Statemachine<States, States extends {\n    state: T\n} ? States : never>\n}\n\nexport type Statemachine<States extends TStates, State extends TStates = States> = State & MachineMethods<States>\n\nconst INITIAL_STATE = Symbol('INITIAL_STATE')\nconst TRANSITIONS = Symbol('TRANSITIONS')\n\nclass StateMachine<States extends TStates, State extends TStates = States>  {\n  state: State[\"state\"]\n  private [INITIAL_STATE]: State[\"state\"]\n  constructor(transitions: StatemachineTransitions<States>, definition: States) {\n    this[INITIAL_STATE] = definition.state\n    this[TRANSITIONS] = transitions\n    Object.assign(this, definition)\n  }\n  transition(state) {\n    const transitions = this[VALUE][TRANSITIONS]\n    if (transitions[this.state].includes(state)) {\n      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])\n      tree.enableMutations()\n      this.state = state\n      Promise.resolve().then(() => tree.blockMutations())\n      return this\n    } else if (process.env.NODE_ENV === 'development' && state !== this.state) {\n      console.warn(`Overmind Statemachine - You tried to transition into \"${state}\", but it is not a valid transition. The valid transitions are ${JSON.stringify(transitions[this.state])}`)\n    } else if (process.env.NODE_ENV === 'development' && state === this.state) {\n      console.warn(`Overmind Statemachine - You tried to transition into \"${state}\", but you are already in this state. Do a \"match\" before running this piece of logic or add it as a valid state transition for this state`)\n    }\n  }\n  matches(state) {\n    if (state === this.state) {\n      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])\n      // Might be used outside of action\n      tree.enableMutations && tree.enableMutations()\n      return true\n    }\n\n    return false\n  }\n}\n\nexport function statemachine<States extends TStates>(definition: StatemachineTransitions<States>, state: States): Statemachine<States> {\n  return new StateMachine(definition, state) as any\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}